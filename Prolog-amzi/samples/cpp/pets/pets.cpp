/*	pets.cpp

	A simple example showing multiple engines.  A class petID
	is derived from class CLogicServer.  It is used to identify
	pets based on sounds, using the pets.xpl compiled Prolog
	program.

	The main entry point creates two instances of petID, each
	having its own Logic Server engine.  Both are running the
	same program, in this example, but come up with different
	results because each has its own unique dynamic database.

	Error handling is done using the C++ catch/throw mechanism.
	To try it, simply rename pets.xpl to something else, and
	watch for the error generated by a missing Prolog load module.
	
	pets.pro

	pet(dog) :- sound(woof).
	pet(cat) :- sound(meow).
	pet(duck) :- sound(quack).
	*/

#include <iostream.h>
#include <stdio.h>
#include <string.h>
#include "amzi.h"

class petID : public CLogicServer
{
public:
	petID();
	virtual ~petID() {};
	void SetSound(char*);
	void GetPet(char*);
private:
	void error(CLSException &e);
};

void main()
{
	try
	{
		petID p1, p2;
		char buf[80];

		p1.SetSound("woof");
		p2.SetSound("quack");

		p1.GetPet(buf);
		cout << "LogicServer one's pet is a " << buf << '\n';
		p2.GetPet(buf);
		cout << "LogicServer two's pet is a " << buf << '\n';
	}
	catch(char* msg)
	{
		cout << msg << '\n';
	}
}

petID::petID()
{
	try
	{
		Init("");
		Load("pets");
	}
	catch(CLSException &e)
	{
		error(e);
	}
}

void petID::SetSound(char * sound)
{
	char buf[80];
	sprintf(buf, "sound(%s)", sound);

	try
	{
		AssertaStr(buf);
	}
	catch(CLSException &e)
	{
		error(e);
	}
}

void petID::GetPet(char * pet)
{
	TERM t;

	try
	{
		if ( ExecStr(&t, "pet(X)") )
			GetArg(t, 1, cSTR, pet);
		else
			strcpy(pet, "unknown");
	}
	catch(CLSException &e)
	{
		error(e);
	}
}

void petID::error(CLSException &e)
{
   char buf[500];

   e.GetMsg(buf, 500);
	cout << "Logic Server Exception " << e.GetRC()
		<< ": " << buf << '\n';
	throw("petID error");
}