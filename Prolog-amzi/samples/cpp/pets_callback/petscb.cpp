/*	pets.cpp

	A simple example showing multiple engines.  A class petID
	is derived from class CLogicServer.  It is used to identify
	pets based on sounds, using the pets.xpl compiled Prolog
	program.

	The main entry point creates two instances of petID, each
	having its own Logic Server engine.  Both are running the
	same program, in this example, but come up with different
	results because each has its own unique dynamic database.

	Error handling is done using the C++ catch/throw mechanism.
	To try it, simply rename pets.xpl to something else, and
	watch for the error generated by a missing Prolog load module.

	This example includes an implementation of an extended predicate,
	used by the Prolog program to prompt the user for information.
	The predicate is defined using AddPred, which now takes a third
	argument.  That third argument can be any pointer you like, and
	it will be passed to the global function, defined in the second
	argument.

	In this example, the third argument to AddPred is the 'this' pointer,
	so it gets passed to ::p_prompt when its called.  ::p_prompt then
	uses that argument to dispatch the function to appropriate
	instance of class petID.

	*/

#include <iostream.h>
#include <stdio.h>
#include <string.h>
#include "amzi.h"

/*	Derive a class from CLogicServer.  The new class has application
	specific member functions, and automatically loads the Prolog
	application during construction.
	*/

class petID : public CLogicServer
{
private:
	int m_petIDid;
public:
	petID(int petidid);
	virtual ~petID() {};
	TF p_prompt();  // The class implementation of the extended predicate
	void GetPet(char*);
private:
	void error(CLSException &e);
};

void main()
{
	// This try/catch catches the character strings thrown
	// by class petID.
	try
	{
		petID p1(1), p2(2);
		char buf[80];

		p1.GetPet(buf);
		cout << "LogicServer one's pet is a " << buf << '\n';
		p2.GetPet(buf);
		cout << "LogicServer two's pet is a " << buf << '\n';
	}
	catch(char* msg)
	{
		cout << msg << '\n';
	}
}

TF EXPFUNC p_prompt(VOIDptr p)
// The global dispatch function.  This is the function address passed
// to the Logic Server as the function to call when the Prolog predicate,
// prompt/2, is called.  When the function address is passed to the
// Prolog engine during initialization, a pointer is also passed, which
// is used as an argument.  In this case, that pointer was the 'this'
// pointer, so this dispatch function can then call the correct instance
// of petID to carry out the function.
{
	return ((petID*)p)->p_prompt();
}

petID::petID(int petidid)
// 
{
	m_petIDid = petidid; // remember who we are for prompts

	// This try/catch is designed to catch Logic Server exceptions
	// and deal with them in the member function error.  Note it
	// catches a reference to the exception object that is thrown
	// by the Logic Server.
	try
	{
		// Use Init2 rather than Init in order to set the
		// .ini parameters from an argument instead of a
		// .ini file.  In this case, the heap, local, control
		// and trail are set to small numbers because we have
		// a small program.
		Init2("h=100, l=100, c=100, t=100");
		// Tell the engine prompt/2 is implemented by
		// calling the global dispatch function, p_prompt,
		// with the argument 'this', used to get control
		// back in this instance of petID.
		AddPred("prompt", 2, &::p_prompt, this);
		Load("pets");
	}
	catch(CLSException &e)
	{
		error(e);
	}
}

TF petID::p_prompt()
{
	char answer[80];
	char prompt[80];

	try
	{
		GetParm(1, cSTR, prompt);

		cout << "Logic Server " <<  m_petIDid
			<< " wants to know\n";
		cout << prompt;
		cin >> answer;

		return UnifyParm(2, cATOM, answer);
	}
	catch(CLSException &e)
	{
		error(e);
		return FALSE;
	}
}

void petID::GetPet(char * pet)
{
	TERM t;

	try
	{
		if ( ExecStr(&t, "pet(X)") )
			GetArg(t, 1, cSTR, pet);
		else
			strcpy(pet, "unknown");
	}
	catch(CLSException &e)
	{
		error(e);
	}
}

const int MAXMSG=512;

void petID::error(CLSException &e)
// The Logic Server exception object has member functions that
// let you extract details.  In this case we pick up the return
// code (GetRC) and the text of the error message (GetMsg).  Both
// are simply displayed, and then a character string is thrown for
// the main function to catch.
{
	char buf[MAXMSG];
	e.GetMsg(buf, MAXMSG);
	cout << "Logic Server Exception " << e.GetRC()
		<< ": " << buf << '\n';
	throw("petID error");
}